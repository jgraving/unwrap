formula = form_var,
data = dt_var,
family = unwrap_von_mises,
stanvars = stan_unwrap_fun +
modulo_circular_fun +
stan_softkappamu,
prior = prior_var,
silent = 2,
cores = 4,
backend = 'cmdstan')
sm_var = summary(model_var)
print(sm_var, digits = 2)
#betai looks bad, but good after unwrapping
#beta0 and betai look bad, but good after unwrapping
UnwrapRhats(model_var,
variable = '^b_beta')
draws_var = as_draws_df(model_var)
par(pty = 's')
par(mar = c(0,0,0,0),
mfrow = c(3,4))
for(i in 1:length(id_var) ) {
mu_name = paste0('b_betai_ID',i)
kappa_name = paste0('r_ID__kappa[',i,',Intercept]')
PCfun(id_var[[i]],
col = col_obs,
sep = 0.05,
shrink = 1.25,
plot_rho = FALSE)
arrows.circular(x = mu_var[i],
y = A1(kappa_id_var[i]),
col = col_obs,
lwd = 5,
length = 0.1/1.25 )
Draws2Cont(draws_var,
x_string = 'sin(b_beta0_Intercept + get(mu_name)) *A1(softplus(Intercept_kappa+get(kappa_name)))',
y_string = 'cos(b_beta0_Intercept + get(mu_name))* A1(softplus(Intercept_kappa+get(kappa_name)))' )
with(draws_var,
arrows.circular(x = median.circular(
circular(x = mod_circular(b_beta0_Intercept + get(mu_name)),
units = 'radians',
rotation = 'clock',
zero = pi/2) )[1],
y = A1(softplus(median(Intercept_kappa+get(kappa_name)))),
lwd = 2, length = 0.1/1.25,
col = adjustcolor(col_sd, alpha.f = 200/255)) )
}
#Add the population of biases
DescriptCplot(k = kappa_mu_var,
ndata = 10,
refline = 0,
sdcol = NA,
denscol = NA,
pcol = NA,
cicol = NA,
mvcol = col_rho )
points.circular(mu_var,
bins = 360/5-1,
stack = TRUE,
sep = 0.05,
shrink = 1.25,
col = col_rho )
Draws2Cont(draws = draws_var,
x_string = 'sin(b_beta0_Intercept) *A1(softplus(kappa_mu))',
y_string = 'cos(b_beta0_Intercept)* A1(softplus(kappa_mu))' )
with(draws_var,
arrows.circular(x = mean.circular(
circular(b_beta0_Intercept,
units = 'radians',
rotation = 'clock',
zero = pi/2) )[1],
y = A1(softplus(median(kappa_mu))),
lwd = 2,
length = 0.1/1.25,
col = adjustcolor(col_sd, alpha.f = 200/255)) )
with(draws_var,
paste0(mean(unwrap_circular_deg(b_beta0_Intercept) > 0)*100, '%') ) #partial pooling allows accurate estimate
with(draws_var,
VertHist(data = unwrap_circular_deg(b_beta0_Intercept),
main = '\npop. mean direction',
ylim = c(-180, 180),
col = adjustcolor(col_sd,
alpha.f = 100/255),
cex.axis = 0.7))
abline(h = 0,
col = col_rho,
lwd = 7)
#condition level change in heading of 30°
delta_mu = circular(x = 30,
units = 'degrees',
rotation = 'clock',
zero = pi/2)
#individual differences with kappa = 3
kappa_mu_hd = 4.0
#mean individual highly concentrated
kappa_hd_mean = 3.0
#large variance in individual accuracy
kappa_hd_sd = 2.5
set.seed(0120810506)#ISBN Batschelet, 1981
kappa_id_hd = rnorm(n = ndata/2,
mean = kappa_hd_mean,
sd = kappa_hd_sd)
#rectified
kappa_id_hd[kappa_id_hd<0] = 0
# list of circular datasets
set.seed(0120810506)#ISBN Batschelet, 1981
mu_hd = rvonmises(n = ndata/2,
mu = c0,
kappa = kappa_mu_hd)
mu_delta = rvonmises(n = ndata/2,
mu = c0+delta_mu,
kappa = kappa_mu_hd)
par(pty = 's')
par(mar = c(0,0,0,0))
par(mfrow = c(3,5))
#before turn
id_hd = mapply(m = mu_hd,
k = round(kappa_id_hd,2),
FUN = DescriptCplot,
save_sample = TRUE,
ndata = 20,
refline = 0,
sdcol = NA,
denscol = NA,
pcol = col_obs,
mvcol = col_obs,
lwd = 5,
seed = 0120810506, #ISBN Batschelet, 1981
SIMPLIFY = FALSE)
#after turn
id_delta = mapply(m = mu_delta,
k = round(kappa_id_hd,2),
FUN = DescriptCplot,
save_sample = TRUE,
pcol = col_treat,
mvcol = col_treat,
lwd = 5,
ndata = 20,
refline = 0,
sdcol = NA,
denscol = NA,
seed = 1981,#Publication year Batschelet
SIMPLIFY = FALSE)
#Add the population of biases
DescriptCplot(m = delta_mu,
k = kappa_mu_hd,
ndata = ndata,
refline = 0,
sdcol = NA,
denscol = NA,
pcol = NA,
cicol = col_sd,
mvcol = col_sd
)
points.circular(mu_delta,
bins = 360/5-1,
stack = TRUE,
sep = 0.05,
shrink = 1.25,
col = col_rho
)
#Add decription of the average individual
DescriptCplot(k = kappa_hd_mean,
ndata = ndata/2,
refline = 0,
sdcol = NA,
denscol = NA,
pcol = NA,
cicol = col_rho,
mvcol = col_rho
)
kappa_id_hd_ci = kappa_hd_mean +
kappa_hd_sd *
qnorm(c(0,1) + c(1,-1)*0.05/2)
#rectify
kappa_id_hd_ci[kappa_id_hd_ci<0] = 0
arrows(x0 = sin(c0),
x1 = sin(c0),
y0 = A1(kappa_id_hd_ci[1]),
y1 = A1(kappa_id_hd_ci[2]),
lwd = 7,
col = adjustcolor(col = col_sd2,
alpha.f = 100/255),
length = 0.05,
angle = 90,
code = 3,
lend = 'butt'
)
mtext(text = paste0('(',paste(signif(kappa_id_hd_ci, 2), collapse = ' '), ')'),
side = 1,
line = -1)
dt_comb_hd = do.call(what = c,
args = id_hd)
PCfun(angles = dt_comb_hd,
col = 'gray25',
shrink = 3.0)
mle_comb_hd = mle.vonmises(x = dt_comb_hd,bias = TRUE)
ci_comb_hd = with(mle_comb_hd,
CI_vM(angles = dt_comb_hd,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_hd,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_pdf,
length = 0.1
)
}
)
dt_comb_delta = do.call(what = c,
args = id_delta)
PCfun(angles = dt_comb_delta,
col = 'darkslategray',
shrink = 3.0)
mle_comb_delta = mle.vonmises(x = dt_comb_delta,bias = TRUE)
ci_comb_delta = with(mle_comb_delta,
CI_vM(angles = dt_comb_delta,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_delta,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_pdf,
length = 0.1
)
}
)
dt_comb_diffs = dt_comb_delta - dt_comb_hd
PCfun(angles = dt_comb_diffs,
col = col_sd2,
shrink = 3.0)
mle_comb_diffs = mle.vonmises(x = dt_comb_diffs,bias = TRUE)
ci_comb_diffs = with(mle_comb_diffs,
CI_vM(angles = dt_comb_diffs,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_diffs,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_sd,
length = 0.1
)
}
)
pnorm(0, 3, 2.5)
#condition level change in heading of 30°
delta_mu_hd = circular(x = 30,
units = 'degrees',
rotation = 'clock',
zero = pi/2)
#individual differences with kappa = 3
kappa_mu_hd = 4.0
#mean individual highly concentrated
kappa_hd_mean = 3.0
#large variance in individual accuracy
kappa_hd_sd = 2.5
#strong possibilty of uniform distribution
print( paste0( round(
pnorm(q = 0,
mean =  kappa_hd_mean,
sd =  kappa_hd_sd) * 100), "%")
)
set.seed(0120810506)#ISBN Batschelet, 1981
kappa_id_hd = rnorm(n = ndata/2,
mean = kappa_hd_mean,
sd = kappa_hd_sd)
#rectified
kappa_id_hd[kappa_id_hd<0] = 0
# list of circular datasets
set.seed(0120810506)#ISBN Batschelet, 1981
mu_hd = rvonmises(n = ndata/2,
mu = c0,
kappa = kappa_mu_hd)
mu_delta = rvonmises(n = ndata/2,
mu = c0+delta_mu_hd,
kappa = kappa_mu_hd)
par(pty = 's')
par(mar = c(0,0,0,0))
par(mfrow = c(3,5))
#before turn
id_hd = mapply(m = mu_hd,
k = round(kappa_id_hd,2),
FUN = DescriptCplot,
save_sample = TRUE,
ndata = 20,
refline = 0,
sdcol = NA,
denscol = NA,
pcol = col_obs,
mvcol = col_obs,
lwd = 5,
seed = 0120810506, #ISBN Batschelet, 1981
SIMPLIFY = FALSE)
#after turn
id_delta = mapply(m = mu_delta,
k = round(kappa_id_hd,2),
FUN = DescriptCplot,
save_sample = TRUE,
pcol = col_treat,
mvcol = col_treat,
lwd = 5,
ndata = 20,
refline = 0,
sdcol = NA,
denscol = NA,
seed = 1981,#Publication year Batschelet
SIMPLIFY = FALSE)
#Add the population of biases
DescriptCplot(m = delta_mu_hd,
k = kappa_mu_hd,
ndata = ndata,
refline = 0,
sdcol = NA,
denscol = NA,
pcol = NA,
cicol = col_sd,
mvcol = col_sd
)
points.circular(mu_delta,
bins = 360/5-1,
stack = TRUE,
sep = 0.05,
shrink = 1.25,
col = col_rho
)
#Add decription of the average individual
DescriptCplot(k = kappa_hd_mean,
ndata = ndata/2,
refline = 0,
sdcol = NA,
denscol = NA,
pcol = NA,
cicol = col_rho,
mvcol = col_rho
)
kappa_id_hd_ci = kappa_hd_mean +
kappa_hd_sd *
qnorm(c(0,1) + c(1,-1)*0.05/2)
#rectify
kappa_id_hd_ci[kappa_id_hd_ci<0] = 0
arrows(x0 = sin(c0),
x1 = sin(c0),
y0 = A1(kappa_id_hd_ci[1]),
y1 = A1(kappa_id_hd_ci[2]),
lwd = 7,
col = adjustcolor(col = col_sd2,
alpha.f = 100/255),
length = 0.05,
angle = 90,
code = 3,
lend = 'butt'
)
mtext(text = paste0('(',paste(signif(kappa_id_hd_ci, 2), collapse = ' '), ')'),
side = 1,
line = -1)
dt_comb_hd = do.call(what = c,
args = id_hd)
PCfun(angles = dt_comb_hd,
col = 'gray25',
shrink = 3.0)
mle_comb_hd = mle.vonmises(x = dt_comb_hd,bias = TRUE)
ci_comb_hd = with(mle_comb_hd,
CI_vM(angles = dt_comb_hd,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_hd,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_pdf,
length = 0.1
)
}
)
dt_comb_delta = do.call(what = c,
args = id_delta)
PCfun(angles = dt_comb_delta,
col = 'darkslategray',
shrink = 3.0)
mle_comb_delta = mle.vonmises(x = dt_comb_delta,bias = TRUE)
ci_comb_delta = with(mle_comb_delta,
CI_vM(angles = dt_comb_delta,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_delta,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_pdf,
length = 0.1
)
}
)
dt_comb_diffs = dt_comb_delta - dt_comb_hd
PCfun(angles = dt_comb_diffs,
col = col_sd2,
shrink = 3.0)
mle_comb_diffs = mle.vonmises(x = dt_comb_diffs,bias = TRUE)
ci_comb_diffs = with(mle_comb_diffs,
CI_vM(angles = dt_comb_diffs,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_diffs,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_sd,
length = 0.1
)
}
)
range(deg(MardiaSD(k = kappa_id_hd)))
#high density around true mean
rayleigh.test(dt_comb_diffs, mu = delta_mu_hd)
#but also at zero difference
rayleigh.test(dt_comb_diffs, mu = c0)
#
#There is a difference between the distributions
watson.two.test(dt_comb_hd, dt_comb_delta)
#collect data
dt_hd = data.frame(y = as.numeric( rad(c(dt_comb_hd, dt_comb_delta)) ),#angles as a numeric vector in radians
x = c(rep(0, times = length(dt_comb_hd)),
rep(1, times = length(dt_comb_delta)) ),
ID = factor(x = #individual labels as an unordered categorical (factor)
c(sort(rep(1:length(mu_hd), 20)),
sort(rep(1:length(mu_delta), 20))),
ordered = FALSE)
)
#set up formula with both 'nonlinear' and linear predictors
form_hd = bf(y ~ mu,
nlf(mu ~ beta0 + betai),#a nonlinear formula
beta0 ~ 1 + x,
betai ~ 0 + ID + x:ID,
kappa ~ 1 + x +  (1 + x|ID),#a linear formula
family = unwrap_von_mises)
softplus
#the individual effects on change in heading need a new parameter
stan_kappamux = stanvar(scode = "
real softkappamux;
",
block = "parameters") +
stanvar(scode = "
real kappa_mu_x = log1p_exp(softkappamu + softkappamux);
",
block = 'genquant')
prior_hd = prior('normal(0, 3*pi()/2)',class = 'b', nlpar = 'beta0') + #wider prior helps avoid bias
prior('normal(0, pi()/2)',class = 'b', nlpar = 'beta0', coef = 'x') + #expectation of moderate sized turns
set_prior(prior = 'target += unwrap_von_mises_vect_lpdf(b_betai[1:N_1] | 0, log1p_exp(softkappamu))', check = FALSE) + #prior for the control
set_prior(prior = 'target += unwrap_von_mises_vect_lpdf(b_betai[(N_1+1):(M_1*N_1)] | 0, log1p_exp(softkappamu+softkappamux))', check = FALSE) + #prior for the treatment (2nd N_1 betai estimates)
set_prior(prior = 'target += lognormal_lpdf(log1p_exp(softkappamu) | log(15), 0.6)', check = FALSE) + #prior to higher values, indiv differences should be small
set_prior(prior = 'target += normal_lpdf(softkappamux | 0, 1.0)', check = FALSE) + #expect only small effect of treatment on distrib. of individuals
prior('normal( 3.0, 3.0)', class = 'Intercept', dpar = 'kappa') + #shouldn't be too tight, want to estimate
prior('normal( 0.0, 3.0)', class = 'b', dpar = 'kappa', coef = 'x') + #turns should not affect population accuracy
prior('student_t(3, 0, 3.0)', class = 'sd', dpar = 'kappa') +  #now expect substantial variation, but too much makes sampling unstable
prior('student_t(3, 0, 3.0)', class = 'sd', dpar = 'kappa', coef = 'x', group = 'ID') #now expect substantial variation, but too much makes sampling unstable
#run the model
model_hd = brm(
formula = form_hd,
data = dt_hd,
family = unwrap_von_mises,
stanvars = stan_unwrap_fun +
modulo_circular_fun +
stan_softkappamu +
stan_kappamux,
prior = prior_hd,
silent = 2,
cores = 4,
backend = 'cmdstan')
sm_hd = summary(model_hd)
print(sm_hd, digits = 2)
#betai looks bad, but good after unwrapping
#beta0 and betai look bad, but good after unwrapping
UnwrapRhats(model_hd,
variable = '^b_beta')
