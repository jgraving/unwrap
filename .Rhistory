sdcol = NA,
denscol = NA,
pcol = NA,
cicol = col_rho,
mvcol = col_rho
)
kappa_id_hd_ci = kappa_hd_mean +
kappa_hd_sd *
qnorm(c(0,1) + c(1,-1)*0.05/2)
#rectify
kappa_id_hd_ci[kappa_id_hd_ci<0] = 0
arrows(x0 = sin(c0),
x1 = sin(c0),
y0 = A1(kappa_id_hd_ci[1]),
y1 = A1(kappa_id_hd_ci[2]),
lwd = 7,
col = adjustcolor(col = col_sd2,
alpha.f = 100/255),
length = 0.05,
angle = 90,
code = 3,
lend = 'butt'
)
mtext(text = paste0('(',paste(signif(kappa_id_hd_ci, 2), collapse = ' '), ')'),
side = 1,
line = -1)
dt_comb_hd = do.call(what = c,
args = id_hd)
PCfun(angles = dt_comb_hd,
col = 'gray25',
shrink = 3.0)
mle_comb_hd = mle.vonmises(x = dt_comb_hd,bias = TRUE)
ci_comb_hd = with(mle_comb_hd,
CI_vM(angles = dt_comb_hd,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_hd,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_pdf,
length = 0.1
)
}
)
dt_comb_delta = do.call(what = c,
args = id_delta)
PCfun(angles = dt_comb_delta,
col = 'darkslategray',
shrink = 3.0)
mle_comb_delta = mle.vonmises(x = dt_comb_delta,bias = TRUE)
ci_comb_delta = with(mle_comb_delta,
CI_vM(angles = dt_comb_delta,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_delta,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_pdf,
length = 0.1
)
}
)
dt_comb_diffs = dt_comb_delta - dt_comb_hd
PCfun(angles = dt_comb_diffs,
col = col_sd2,
shrink = 3.0)
mle_comb_diffs = mle.vonmises(x = dt_comb_diffs,bias = TRUE)
ci_comb_diffs = with(mle_comb_diffs,
CI_vM(angles = dt_comb_diffs,
m1 = mu,
k1 = kappa,
alternative = 'two.sided')
)
with(mle_comb_diffs,
{
arrows.circular(x = circular(mu,
units = 'degrees',
rotation = 'clock',
zero = pi/2),
y = A1(kappa),
lwd = 3,
col = col_sd,
length = 0.1
)
}
)
#collect data
dt_hd = data.frame(y = as.numeric( rad(c(dt_comb_hd, dt_comb_delta)) ),#angles as a numeric vector in radians
x = c(rep(0, times = length(dt_comb_hd)),
rep(1, times = length(dt_comb_delta)) ),
ID = factor(x = #individual labels as an unordered categorical (factor)
c(sort(rep(1:length(mu_hd), 20)),
sort(rep(1:length(mu_delta), 20))),
ordered = FALSE)
)
#set up formula with both 'nonlinear' and linear predictors
form_hd = bf(y ~ mu,
nlf(mu ~ beta0 + betai),#a nonlinear formula
beta0 ~ 1 + x,
betai ~ 0 + ID + x:ID,
kappa ~ 1 + x +  (1 + x|ID),#a linear formula
family = unwrap_von_mises)
#the individual effects on change in heading need a new parameter
stan_kappamux = stanvar(scode = "
real softkappamux;
",
block = "parameters") +
stanvar(scode = "
real kappa_mu_x = log1p_exp(softkappamu + softkappamux);
",
block = 'genquant')
prior_hd = prior('normal(0, 3*pi()/2)',class = 'b', nlpar = 'beta0') + #wider prior helps avoid bias
prior('normal(0, pi()/2)',class = 'b', nlpar = 'beta0', coef = 'x') + #expectation of moderate sized turns
set_prior(prior = 'target += unwrap_von_mises_vect_lpdf(b_betai[1:N_1] | 0, log1p_exp(softkappamu))', check = FALSE) + #prior for the control
set_prior(prior = 'target += unwrap_von_mises_vect_lpdf(b_betai[1:N_1] + b_betai[(N_1+1):(M_1*N_1)] | 0, log1p_exp(softkappamu+softkappamux))', check = FALSE) + #prior for the treatment (2nd N_1 betai estimates)
set_prior(prior = 'target += lognormal_lpdf(log1p_exp(softkappamu) | log(15), 0.6)', check = FALSE) + #prior to higher values, indiv differences should be small
set_prior(prior = 'target += normal_lpdf(softkappamux | 0, 1.0)', check = FALSE) + #expect only small effect of treatment on distrib. of individuals
prior('normal( 3.0, 3.0)', class = 'Intercept', dpar = 'kappa') + #shouldn't be too tight, want to estimate
prior('normal( 0.0, 3.0)', class = 'b', dpar = 'kappa', coef = 'x') + #turns should not affect population accuracy
prior('student_t(3, 0, 3.0)', class = 'sd', dpar = 'kappa') +  #now expect substantial variation, but too much makes sampling unstable
prior('student_t(3, 0, 3.0)', class = 'sd', dpar = 'kappa', coef = 'x', group = 'ID') #now expect substantial variation, but too much makes sampling unstable
#run the model
model_hd = brm(
formula = form_hd,
data = dt_hd,
family = unwrap_von_mises,
stanvars = stan_unwrap_fun +
modulo_circular_fun +
stan_softkappamu +
stan_kappamux,
prior = prior_hd,
silent = 2,
cores = 4,
backend = 'cmdstan')
#betai looks bad, but good after unwrapping
#beta0 and betai look bad, but good after unwrapping
UnwrapRhats(model_hd,
variable = '^b_beta')
sm_hd = summary(model_hd)
print(sm_hd, digits = 2)
#betai looks bad, but good after unwrapping
#beta0 and betai look bad, but good after unwrapping
UnwrapRhats(model_hd,
variable = '^b_beta')
form_hd_kappa = bf(y ~ mu,
nlf(mu ~ beta0 + betai),#a nonlinear formula
beta0 ~ 1,
betai ~ 0 + ID,
kappa ~ 1 + x +  (1 + x|ID),#a linear formula
family = unwrap_von_mises)
form_hd_null = bf(y ~ mu,
nlf(mu ~ beta0 + betai),#a nonlinear formula
beta0 ~ 1,
betai ~ 0 + ID,
kappa ~ 1 + (1 |ID),#a linear formula
family = unwrap_von_mises)
#without effects of x on mu
prior_hd_kappa = prior('normal(0, 3*pi()/2)',class = 'b', nlpar = 'beta0') + #wider prior helps avoid bias
set_prior(prior = 'target += unwrap_von_mises_vect_lpdf(b_betai | 0, log1p_exp(softkappamu))', check = FALSE) + #prior for the control
set_prior(prior = 'target += lognormal_lpdf(log1p_exp(softkappamu) | log(15), 0.6)', check = FALSE) + #prior to higher values, indiv differences should be small
prior('normal( 3.0, 3.0)', class = 'Intercept', dpar = 'kappa') + #shouldn't be too tight, want to estimate
prior('normal( 0.0, 3.0)', class = 'b', dpar = 'kappa', coef = 'x') + #turns should not affect population accuracy
prior('student_t(3, 0, 3.0)', class = 'sd', dpar = 'kappa') +  #now expect substantial variation, but too much makes sampling unstable
prior('student_t(3, 0, 3.0)', class = 'sd', dpar = 'kappa', coef = 'x', group = 'ID') #now expect substantial variation, but too much makes sampling unstable
#without effects of x
prior_hd_null = prior('normal(0, 3*pi()/2)',class = 'b', nlpar = 'beta0') + #wider prior helps avoid bias
set_prior(prior = 'target += unwrap_von_mises_vect_lpdf(b_betai | 0, log1p_exp(softkappamu))', check = FALSE) + #prior for the control
set_prior(prior = 'target += lognormal_lpdf(log1p_exp(softkappamu) | log(15), 0.6)', check = FALSE) + #prior to higher values, indiv differences should be small
prior('normal( 3.0, 3.0)', class = 'Intercept', dpar = 'kappa') + #shouldn't be too tight, want to estimate
prior('student_t(3, 0, 3.0)', class = 'sd', dpar = 'kappa')  #now expect substantial variation, but too much makes sampling unstable
#refit and save all parameters for model comparison
model_hd_treatment = brm(
formula = form_hd,
data = dt_hd,
family = unwrap_von_mises,
stanvars = stan_unwrap_fun +
modulo_circular_fun +
stan_softkappamu +
stan_kappamux,
prior = prior_hd,
cores = 4,
silent = 2, # without printing
backend = 'cmdstan',
save_pars = save_pars(all = TRUE),
control = list(adapt_delta = 0.97)#slower, but more robust sampling
)
model_hd_kappa = brm(
formula = form_hd_kappa,
data = dt_hd,
family = unwrap_von_mises,
stanvars = stan_unwrap_fun +
modulo_circular_fun +
stan_softkappamu, #without the kappamux variable
prior = prior_hd_kappa,
cores = 4,
silent = 2, # without printing
save_pars = save_pars(all = TRUE),
backend = 'cmdstan',
control = list(adapt_delta = 0.97)#slower, but more robust sampling
)
model_hd_null = brm(
formula = form_hd_null,
data = dt_hd,
family = unwrap_von_mises,
stanvars = stan_unwrap_fun +
modulo_circular_fun +
stan_softkappamu,#without the kappamux variable
prior = prior_hd_null,
cores = 4,
silent = 2, # without printing
save_pars = save_pars(all = TRUE),
backend = 'cmdstan',
control = list(adapt_delta = 0.97)#slower, but more robust sampling
)
summary(model_hd_treatment)
UnwrapRhats(model_hd_treatment,
variable = '^b_beta')
summary(model_hd_kappa)
UnwrapRhats(model_hd_kappa,
variable = '^b_beta')
summary(model_hd_null)
UnwrapRhats(model_hd_null,
variable = '^b_beta')
#better predictions should justify fitting a treatment model
loo_null = loo(model_hd_null, moment_match = TRUE)
loo_kappa = loo(model_hd_kappa, moment_match = TRUE, reloo = TRUE)# Pareto-k warning
loo_treat = loo(model_hd_treatment, moment_match = TRUE)
lc_nulltreat = loo_compare(loo_null, loo_kappa, loo_treat)
print(lc_nulltreat)
lc_plot = data.frame(elpd = c(loo_null$estimates['elpd_loo','Estimate'],
loo_kappa$estimates['elpd_loo','Estimate'],
loo_treat$estimates['elpd_loo','Estimate'],
loo_kappa$estimates['elpd_loo','Estimate'] - lc_nulltreat[2,'elpd_diff']),
se = c(loo_null$estimates['elpd_loo','SE'],
loo_kappa$estimates['elpd_loo','SE'],
loo_treat$estimates['elpd_loo','SE'],
lc_nulltreat[2,'se_diff'])
)
par(mar = c(0,4,0,4),
mfrow = c(1,1))
plot(x = 1:dim(lc_plot)[1],
y = lc_plot$elpd,
xlab = '',
ylab = 'expected log predictive density',
xlim = c(1,dim(lc_plot)[1]) + c(-1,1)*0.5,
ylim = with(lc_plot, {range(elpd+se%*% t(c(-2,2)))}), #within 2sigma of all estimates
pch = 19,
col = c(col_obs, col_kappa, col_treat, col_rho),
cex = 2,
axes = FALSE)
with(lc_plot,
{
arrows(x0 = 1:dim(lc_plot)[1],
x1 = 1:dim(lc_plot)[1],
y0 = elpd - se,
y1 = elpd + se,
code = 3,
angle = 90,
length = 0.1,
lwd = 3,
col =  c(col_obs, col_kappa, col_treat, col_rho)
)
}
)
axis(2,
at = pretty(c(0,
with(lc_plot, {range(elpd+se%*% t(c(-2,2)))}))
)
)
axis(4,
at = with(lc_plot,
{
seq(from = elpd[2], to = elpd[dim(lc_plot)[1]] + se[dim(lc_plot)[1]]*4, by = 20)
}
),
labels = with(lc_plot,
{
seq(from = 0, to =  elpd[dim(lc_plot)[1]] + se[dim(lc_plot)[1]]*4 - elpd[2],  by = 20)
}
),
col = col_rho
)
abline(h = lc_plot$elpd[2],
col = 'gray')
mtext(text = 'ELPD difference',
side = 4,
line = 3
)
mtext(side = 1,
line = -1,
at = 1:dim(lc_plot)[1],
text = c('null\nmodel',
'kappa\nmodel',
'mu & kappa\nmodel',
'difference'),
col = c(col_obs, col_kappa, col_treat, col_rho)
)
draws_treat = as_draws_df(model_hd_treatment)
par(pty = 's')
par(mar = c(0,0,0,0),
mfrow = c(2,length(mu_hd)))
#control
for(i in 1:length(mu_hd) )
{
mu_name = paste0('b_betai_ID',i)
kappa_name = paste0('r_ID__kappa[',i,',Intercept]')
PCfun(id_hd[[i]],
col = col_obs,
sep = 0.05,
shrink = 1.25,
plot_rho = FALSE)
Draws2Cont(draws_treat,
x_string = 'sin(b_beta0_Intercept + get(mu_name))*
A1(softplus(Intercept_kappa+get(kappa_name)))',
y_string = 'cos(b_beta0_Intercept + get(mu_name))*
A1(softplus(Intercept_kappa+get(kappa_name)))',
ngrid = 100, # needs higher resolution to avoid spillover
cropc = TRUE
)
arrows.circular(x = mu_hd[i],
y = A1(kappa_id_hd[i]),
col = col_obs,
lwd = 5,
length = 0.1/1.25
)
with(draws_treat,
arrows.circular(x = median.circular(
circular(x =
mod_circular(b_beta0_Intercept + get(mu_name)),
units = 'radians',
rotation = 'clock',
zero = pi/2)
)[1],
y = A1(softplus(median(Intercept_kappa+get(kappa_name)))),
lwd = 2,
length = 0.1/1.25,
col = adjustcolor(col_sd, alpha.f = 200/255))
)
}
#treatment
for(i in 1:length(mu_delta) )
{
mu_name = paste0('b_betai_ID',i)
mu_delta_name = paste0('b_betai_ID',i , ':x')
kappa_name = paste0('r_ID__kappa[',i,',Intercept]')
kappa_delta_name = paste0('r_ID__kappa[',i,',x]')
PCfun(id_delta[[i]],
col = col_treat,
sep = 0.05,
shrink = 1.25,
plot_rho = FALSE)
Draws2Cont(draws_treat,
x_string = 'sin(b_beta0_Intercept + b_beta0_x + get(mu_name) + get(mu_delta_name))*
A1(softplus(Intercept_kappa+b_kappa_x+get(kappa_name)+get(kappa_delta_name)))',
y_string = 'cos(b_beta0_Intercept + b_beta0_x + get(mu_name) + get(mu_delta_name))*
A1(softplus(Intercept_kappa+b_kappa_x+get(kappa_name)+get(kappa_delta_name)))',
ngrid = 100, # needs higher resolution to avoid spillover
cropc = TRUE
)
arrows.circular(x = mu_delta[i],
y = A1(kappa_id_hd[i]),
col = col_treat,
lwd = 5,
length = 0.1/1.25
)
with(draws_treat,
arrows.circular(x = median.circular(
circular(x =
mod_circular(b_beta0_Intercept+ b_beta0_x + get(mu_name)  + get(mu_delta_name)),
units = 'radians',
rotation = 'clock',
zero = pi/2)
)[1],
y = A1(softplus(median(Intercept_kappa + b_kappa_x + get(kappa_name) + get(kappa_delta_name)))),
lwd = 2,
length = 0.1/1.25,
col = adjustcolor(col_sd, alpha.f = 200/255))
)
}
par(mfrow = c(1,4))
#Add the population of biases
DescriptCplot(k = kappa_mu_hd,
ndata = length(mu_hd),
refline = 0,
denscol = NA,
pcol = NA,
sdcol = NA,
mvcol = col_obs
)
points.circular(mu_hd,
bins = 360/5-1,
stack = TRUE,
sep = 0.05,
shrink = 1.25,
col = col_rho
)
Draws2Cont(draws = draws_treat,
x_string = 'sin(b_beta0_Intercept)*
A1(kappa_mu)',
y_string = 'cos(b_beta0_Intercept)*
A1(kappa_mu)',
ngrid = 100, # needs higher resolution to avoid spillover
cropc = TRUE
)
with(draws_treat,
arrows.circular(x = mean.circular(circular(b_beta0_Intercept,
units = 'radians',
rotation = 'clock',
zero = pi/2)
)[1],
y = A1(median(kappa_mu)),
lwd = 2,
length = 0.1/1.25,
col = adjustcolor(col_sd, alpha.f = 200/255))
)
#Add the population of turns
DescriptCplot(m = delta_mu_hd,
k = kappa_mu_hd,
ndata = length(mu_hd),
refline = 0,
denscol = NA,
pcol = NA,
sdcol = NA,
mvcol = col_treat
)
points.circular(mu_delta,
bins = 360/5-1,
stack = TRUE,
sep = 0.05,
shrink = 1.25,
col = col_rho
)
Draws2Cont(draws = draws_treat,
x_string = 'sin(b_beta0_x)*
A1(kappa_mu_x)',
y_string = 'cos(b_beta0_x)*
A1(kappa_mu_x)',
ngrid = 100, # needs higher resolution to avoid spillover
cropc = TRUE
)
with(draws_treat,
arrows.circular(x = mean.circular(circular(b_beta0_x,
units = 'radians',
rotation = 'clock',
zero = pi/2)
)[1],
y = A1(median(kappa_mu_x)),
lwd = 2,
length = 0.1/1.25,
col = adjustcolor(col_sd, alpha.f = 200/255))
)
#Add description of the average individual
DescriptCplot(k = kappa_hd_mean,
ndata = ndata/2,
refline = 0,
denscol = NA,
pcol = NA,
sdcol = NA,
mvcol = col_obs
)
Draws2Cont(draws = draws_treat,
x_string = 'sin(b_beta0_Intercept)*
A1(softplus(Intercept_kappa))',
y_string = 'cos(b_beta0_Intercept)*
A1(softplus(Intercept_kappa))',
ngrid = 100, # needs higher resolution to avoid spillover
cropc = TRUE
)
with(draws_treat,
arrows.circular(x = mean.circular(circular(b_beta0_Intercept,
units = 'radians',
rotation = 'clock',
zero = pi/2)
)[1],
y = A1(softplus(median(Intercept_kappa))),
lwd = 2,
length = 0.1/1.25,
col = adjustcolor(col_sd, alpha.f = 200/255))
)
#estimate somewhat favours a turn
with(draws_treat,
paste0(mean(b_beta0_x > 0)*100, '%')
)
with(draws_treat,
VertHist(data = unwrap_circular_deg(b_beta0_x),
main = 'change in mean angle',
ylim = c(-180, 180),
col = adjustcolor(col_sd, alpha.f = 100/255),
cex.axis = 0.7,
axes = FALSE))
axis(side = 1)
axis(side = 2,
at = -6:6*(180/6) )
abline(h = 0,
col = 'gray',
lwd = 7)
model_hd_treatment$model
write.table(x = model_hd_treatment$model, file = "stanmod.txt")
