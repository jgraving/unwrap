---
title: "Circular Dataset Structures"
date: "`r Sys.Date()`"
author: "James Foster"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Details

> **AUTHOR**
>
> James Foster

> **DESCRIPTION**
>
> Examination of different dataset structures that may arise in the study of animal navigation.

> **INPUTS**
>
> `unwrap_functions.R`

> **OUTPUTS**
>
> Plotted results.

> **REFERENCES**
>
> **data types**
>
> Duelli P. & Wehner R.
> (1973) The Spectral Sensitivity of Polarized Light Orientation in Cataglyphis bicolor ( Formicidae , Hymenoptera ) *Journal of Comparative Physiology* 53(3) 37-53
>
> Edrich, W., Neumeyer, C.
> and von Helversen, O.
> (1979).
> ‚ÄúAnti-sun orientation‚Äù of bees with regard to a field of ultraviolet light.
> *J. Comp. Physiol.* 134, 151‚Äì157.
>
> **modelling methods**
>
> Sayin S, Couzin-Fuchs E, Petelski I, G√ºnzel Y, Salahshour M, Lee CY, Graving JM, Li L, Deussen O, Sword GA, et al. (2025) The behavioral mechanisms governing collective motion in swarming locusts.
> Science.
> 387(6737):995‚Äì791
>
> Gabry J, ƒåe≈°novar R, Johnson A (2022).
> cmdstanr: R Interface to 'CmdStan'.
> <https://mc-stan.org/cmdstanr/>
>
> B√ºrkner, P.-C.
> (2018).
> Advanced Bayesian Multilevel Modeling with the R Package brms.
> The R Journal 10, 395‚Äì411.
>
> Carpenter, B., Gelman, A., Hoffman, M. D., Lee, D., Goodrich, B., Betancourt, M., Brubaker, M., Guo, J., Li, P. and Riddell, A.
> (2017).
> Stan: A Probabilistic Programming Language.
> Journal of Statistical Software 76 doi: 10.18637/jss.v076.i01

> **TODO**
>
> -   move necessary functions to unwrap_functions.R
> -   make functions for result extraction from BRMS

## Set up workspace

```{r Load functions and packages}
source('unwrap_functions.R')
```

Set up some colours for plotting.

```{r Set up plot colours}
col_kappa = '#1E78B5'#colour for kappa parameter
col_rho = '#F08024' #colour for mean vector length
col_sd = '#E74A29' #colour for SD and mean angle
col_sd2 = '#E57461' #colour for other SD heuristics
col_pdf = adjustcolor(col = '#21A885', # colour for probability density
                      alpha.f = 0.7)
col_obs = '#3E1F51' #colour for control observations
col_treat = '#006400' # colour for treatment observations
```

# Divergence from home direction

In navigation experiments return directions are often compared with the expected home direction to determine if homeward navigation is perturbed.
Here, we simulate example data (ùëõ = 20) generated from a distribution with a mean that differs from the expected direction (0¬∞) by only 15¬∞.

```{r Generate diverging data, echo  = FALSE}
ndata = 20 #sample size

# circular zero expected angle
c0 = circular(x = 0,
              units = 'degrees',
              rotation = 'clock',
              zero = pi/2)
#true mean angle
c15 = circular(x = -15,
              units = 'degrees',
              rotation = 'clock',
              zero = pi/2)

par(pty = 's') # square axes
par(mar = c(0,0,0,0)) # no margins

cd_divergence = DescriptCplot(m = -15, # population mean
                              k = 10, # high concentration
                              refline = 0, # expected direction
                              ndata = ndata,
                              mvcol = col_obs, #distr. mean same colour as observations
                              sdcol = NA, # don't plot SD
                              denscol = NA, # don't plot prob. density
                              save_sample = TRUE)
```

A common short-cut to assess orientation in an expected direction is to use the v-test modification of the Rayleigh test for uniformity.
This tests the hypothesis of uniformity against the alternative of clustering in some direction less than 90¬∞ from the expected direction.
The data are very far from uniform ($\kappa = 10$), and the mean angle is very close to the expected angle (cosine similarity of `cos(rad(-15)) = 97%`), so the test is significant.
Even so, the data show a trend away from the expected angle, 75% of points falling to the left of 0¬∞.

```{r v-test for uniformity}
mean(cd_divergence < 0)
rayleigh.test(cd_divergence, mu = c0)

```

## Fit the model

In order to fit a circular model using the circular modulo and softplus links, we need to define a custom family.
This family

```{r Set up the circular model custom family}
#set up required Stan functions
#circular modulo in Stan code
modulo_circular_fun = stanvar(scode = "
  real modulo_circular(real y) {
    return fmod(y + pi(), 2*pi()) - pi();
  }
",
                           block = 'functions')

#custom likelihood function using the shifted modulo link
stan_unwrap_fun = stanvar(scode = "
  real unwrap_von_mises_lpdf(real y, real mu, real kappa) {
    return von_mises_lpdf(y | modulo_circular(mu), kappa);
  }
  real unwrap_von_mises_rng(real mu, real kappa) {
    return von_mises_rng( modulo_circular(mu) , kappa);
  }
",
                          block = 'functions') 
#define the custom family
unwrap_von_mises = custom_family(
  name = "unwrap_von_mises",
  dpars = c("mu",
            "kappa"),
  links = c('identity',#N.B. the link function is defined via the LPD function
            "softplus"), 
  lb = c(-pi,#lower bound of mu should be -pi
         0),
  ub = c(pi,#upper bound of mu should be pi
         NA),
  type = "real",#takes continuous response data
  # vars = stan_unwrap_fun + modulo_circular_fun
)

```

To fit our model, we need to convert our data from degrees to radians.
It is also recommended to remove additional formatting by converting from class "circular" to class "numeric".
Our formula indicates that each of $\mu$ and $\kappa$ require a single parameter estimate (`~1`).
In this data, we expect a mean direction anywhere on the circle (within $\pi$ of the mean) and high concentration ($\kappa>1$), so highest prior density is set in that range.

```{r Fit a model to the divergence data}
#reformat data for BRMS
dt_divergence = data.frame(y = as.numeric(#remove circular formatting
                                rad(cd_divergence)#convert to radians
                                )
                           )#make a data frame

#formula for a circular model with no predictors
form_divergence = bf(y~1,
                     kappa~1,
                     family = unwrap_von_mises)
#unbiased priors
prior_divergence =  prior('normal(0,2*pi())', class = 'Intercept', dpar = 'mu') +
                     prior('normal(3,3)', class = 'Intercept', dpar = 'kappa')

#fit a generic unwrap model
model_divergence = brm(formula = form_divergence,
             data = dt_divergence,
             family = unwrap_von_mises,
             stanvars = stan_unwrap_fun + modulo_circular_fun,
             prior = prior_divergence,
             silent = 2,
             backend = 'cmdstan'#faster and more reliable
  )

summary(model_divergence)
```

Since the mean direction is far from the wrap-point ($-\pi$ or $\pi$), the `Rhat` convergence heuristic for the mu `Intercept` can be interpreted on the linear scale.
`Rhat` values for both parameters are $<1.01$ and effective sample size (ESS) indicates most of the 4000 draws explored the posterior distribution efficiently, so we can assume that this model has converged.

To inspect the model's predictions, we can extract the post-warmup draws from the model and plot the posterior distribution of estimates alongside the original data.
$\mu$ `Intercept` can be plotted as an angle in radians on its original scale.
For $\kappa$, we need to convert estimates to the correct scale using the `softplus` transform ($\log( \exp(x) + 1)$), and then convert it to mean-vector-length scale using the `A1` function.
There are `4000` posterior estimates, so rather than plotting all of them we'll summarise them as the medians of $\mu$ and $\kappa$ estimates and the normalised 2D kernel density of their mean-vector equivalent.

```{r Plot the model fitted for divergence data}
#extract all "draws" of the posterior as a data.frame
draws_divergence = as_draws_df(model_divergence)

#open the plot with two panels
par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(1,2))
#plot the raw data
PCfun(cd_divergence,
      col = col_obs,
      sep = 0.05,
      shrink = 1.25,
      plot_rho = FALSE)
#plot the estimate density
Draws2Cont(draws_divergence,
           x_string = )
#add the mean vector of the distribution used to simulate the data
arrows.circular(x = circular(-15,
                             units = 'degrees',
                             rotation = 'clock',
                             zero = pi/2),
                y = A1(10),
                col = col_obs,
                lwd = 5,
                length = 0.1/1.25
)

#add the median mean-vector estimate
with(draws_divergence,
     arrows.circular(x = median.circular(x =
                                           circular(Intercept,
                                  rotation = 'clock',
                                  zero = pi/2)
                                  ),
                     y = A1(softplus(x = median(x = Intercept_kappa))),
                     lwd = 2,
                     length = 0.1/1.25,
                     col = adjustcolor(col_sd, alpha.f = 200/255))
)
#add a histogram of estimates for mu-intercept
with(draws_divergence,
     {
      VertHist(data = deg(Intercept), 
               main = '\nmean angle',
               ylim = c(-30, 15),
               col = adjustcolor(col_sd, alpha.f = 100/255),
               cex.axis = 0.7)
     }
)
#line showing expected direction
abline(h = 0,
       col = 'gray',
       lwd = 7)

#calculate the misaligned posterior density 
with(draws_divergence,
     {
       paste0('mu left of expected angle: ',
              mean(Intercept < 0)*100, '%')
      }
     ) #nearly all estimates suggest a leftwards turn
```

The fitted model indicates that the mean direction is to the left of the expected direction in $>99\%$ of ùúá estimates.

## Test the expected angle hypothesis

To test the hypothesis that the true mean direction falls in the expected direction, we can fit another model where this is explicitly stated.
To inform BRMS that we do not want to estimate the mean direction, we use the notation `y~0`, which removes the intercept parameter.
We can now estimate $\kappa$, *assuming* that the mean direction is 0¬∞, using the same prior for kappa as before.

```{r Model comparison observed vs expected mean direction}


#fit a model with mean at 0
model_expect = brm(formula = bf(y~0,
                              kappa~1),
                data = dt_divergence,
                family = unwrap_von_mises,
                prior = prior_divergence[2,], # just the kappa prior,
                stanvars = stan_unwrap_fun + modulo_circular_fun,
                silent = 2,
                backend = 'cmdstan'
                )
#add Leave-One-Out Cross-Validation

loo_divergence = loo(model_divergence)
loo_expected = loo(model_expect)
loo_compare(loo_divergence, loo_expected)
```

The model for a divergent mean direction has higher expected log predictive density (ELPD) than the model for the expected direction.
This ELPD difference is $>2\times$ larger than its standard error, so we can state with some confidence that the hypothesis of a divergence from the expected direction is more likely than the hypothesis of alignment with the expected direction.

In this case, the expected angle model is straightforward to fit because the expected angle is 0¬∞, which is also the default intercept for a `y~0` (no-intercept) model.
If the expected direction were not 0¬∞, we would need to adjust the data to align the expected angle with the `0` intercept, then fit both models (expected direction and divergent direction) to the adjusted data.
Here is an example with the expected angle at -15¬∞.

```{r Model comparison for expected angle not at 0}
#align the data relative to the expected angle
dt_aligned = within(dt_divergence,
                    {
                    y = y - rad(-15)  #subtract the expected angle
                    }
                    )


#we now place our expected angle at -15¬∞, the true mean
model_true = brm(formula = bf(y ~ 0,
                            kappa~1),
               data = dt_aligned, 
               family = unwrap_von_mises,
               prior = prior_divergence[2,], # just the kappa prior
               stanvars = stan_unwrap_fun + modulo_circular_fun,
               silent = 2,
               backend = 'cmdstan'
)

#this model should be compared with another fitted to the
#_same data_
model_false =  brm(formula = bf(y ~ 1,
                            kappa~1),
               data = dt_aligned, 
               family = unwrap_von_mises,
               prior = prior_divergence, # the kappa and mu priors
               stanvars = stan_unwrap_fun + modulo_circular_fun,
               silent = 2,
               backend = 'cmdstan'
)

#both models converge well with rhats [1.000, 1.002]
sm_truefalse = lapply(list(true = model_true, false = model_false), summary)
#their mu estimates are very close, differing by only 2¬∞, with overlapping CI.
round( deg(
  sm_truefalse$false$fixed['Intercept',
                                    1:4]
  ) )

#add Leave-One-Out Cross-Validation
loo_true = loo(model_true)
loo_false = loo(model_false)
loo_compare(loo_true, loo_false)
```

Now the expected direction model has higher predictive power, even though both find a similar mean direction.
If the divergence model had higher predictive power, but within one standard error of the expected direction model, we could not rule out the possibility that the expected direction is the true direction, though evidence would be weaker.

# Change in direction

If the expected direction is not known, it can be estimated from control data and compared with treatment data.
In this example, the two distributions have different random number seeds, to avoid producing two identical distributions of angles with a fixed shift.

```{r Simulate a change in direction}
par(pty = 's')
par(mar = c(0,0,0,0))
par(mfrow = c(1,2))

cd_control = DescriptCplot(m = 180,
                     k = 3,
                     ndata = ndata,
                     mvcol = col_obs,
                     sdcol = NA,
                     denscol = NA,
                     refline = c0,
                     save_sample = TRUE,
                     titleline = -1,#needs to be lower when data are South
                     seed = 1539571)#DOI Papi & Pardi

cd_treatment = DescriptCplot(m = 210,
                       k = 3,
                       ndata = ndata,
                       pcol = col_treat,
                       mvcol = col_treat,
                       sdcol = NA,
                       denscol = NA,
                       refline = c0,
                       save_sample = TRUE,
                       titleline = -1,#needs to be lower when data are South
                     seed = 0120810506) #ISBN Batschelet 1981


```

To model the change in direction, we need to account for potential differences in both direction and concentration between the control and treatment.
We can combine our two sets of angles together into one vector $y$, that is aligned with the vector $x$, which specifies whether the treatment was applied in Boolean logic (yes: $1$, no: $0$).
*N.B.* For stability, a slightly narrower prior on `Intercept`, $N(0,3\pi/2)$, is used.
This reduces the region of $50\%$ prior density from [-240¬∞, 240¬∞] to [-180¬∞, 180¬∞].

```{r Fit treatment direction model}
dt_delta = data.frame(y = rad(
                            as.numeric(
                            c(cd_control,
                              cd_treatment)
                            ) ),
                      x = c(rep(0, length(cd_control)),
                            rep(1, length(cd_treatment)))
                      )

#formula for a circular model with predictor x
form_delta = bf(y~x,
                kappa~x,
                family = unwrap_von_mises)

prior_delta = prior('normal(0,3*pi()/2)', class = 'Intercept', dpar = 'mu') +
        prior('normal(0,pi()/2)', class = 'b', dpar = 'mu') +
        prior('normal(3,3)', class = 'Intercept', dpar = 'kappa') +
        prior('normal(0,3)', class = 'b', dpar = 'kappa')


model_delta =  brm(formula = form_delta,
               data = dt_delta, 
               family = unwrap_von_mises,
               prior = prior_delta, # the kappa and mu priors
               stanvars = stan_unwrap_fun + modulo_circular_fun,
               silent = 2,
               backend = 'cmdstan'
)
summary(model_delta)
```

Because the mean direction for the control now falls precisely at the boundary of $(-\pi, \pi)$, estimates for the `Intercept` parameter with equal likelihood could appear in both positive and negative directions.
The same is also possible for the coefficient `b_x` (treatment change in angle).
If we unwrap these estimates, we can confirm that they converged towards the same angle, even if they moved in different directions.

```{r Unwrap the intercept estimates}
plot(model_delta, ask = FALSE)
#unwrap estimates and convert to degrees
plot(x = model_delta,
     variable = c('Intercept','b_x'),
     transform = unwrap_circular_deg)
#print the rhat for unwrapped estimates
UnwrapRhats(model_delta,
            variable = c('Intercept','b_x'),
            regex = FALSE
            )
```

Now that we have established that the model has converged, we can inspect the model predictions.
To do this we need to apply the model formula to the estimates.
That means that in the control condition we use estimates of `Intercept` ($\mu$) and `Intercept_kappa`, but for the treatment we need `Intercept` plus `b_x` (effect of treatment on $\mu$) and `Intercept_kappa` plus `b_kappa_x` (effect of treatment on $\kappa$).

```{r Inspect predictions for change in direction}
draws_delta = as_draws_df(model_delta)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(1,3))
PCfun(cd_control,
      col = col_obs,
      sep = 0.05,
      shrink = 1.25,
      plot_rho = FALSE)
Draws2Cont(draws_delta,
           x_string = 'sin(Intercept)*A1(softplus(Intercept_kappa))',
           y_string = 'cos(Intercept)*A1(softplus(Intercept_kappa))',
)
arrows.circular(x = circular(180,
                             units = 'degrees',
                             rotation = 'clock',
                             zero = pi/2),
                y = A1(3),
                col = col_obs,
                lwd = 5,
                length = 0.1/1.25
)
with(draws_delta,
     arrows.circular(x = median.circular(x =
                             circular(Intercept,
                                  rotation = 'clock',
                                  zero = pi/2)
                                  ),
                     y = A1(softplus(x = median(x = Intercept_kappa))),
                     lwd = 2,
                     length = 0.1/1.25,
                     col = adjustcolor(col_sd, alpha.f = 200/255))
)

PCfun(cd_treatment,
      col = col_treat,
      sep = 0.05,
      shrink = 1.25,
      plot_rho = FALSE)
Draws2Cont(draws_delta,
           x_string = 'sin(Intercept+b_x)*A1(softplus(Intercept_kappa+b_kappa_x))',
           y_string = 'cos(Intercept+b_x)*A1(softplus(Intercept_kappa+b_kappa_x))',
)
arrows.circular(x = circular(205,
                             units = 'degrees',
                             rotation = 'clock',
                             zero = pi/2),
                y = A1(3),
                col = col_treat,
                lwd = 5,
                length = 0.1/1.25
)
with(draws_delta,
     arrows.circular(x = median.circular(x =
                             circular(Intercept + b_x,
                                  rotation = 'clock',
                                  zero = pi/2)
                                  ),
                     y = A1(softplus(x = median(x = Intercept_kappa +
                                                  b_kappa_x))),
                     lwd = 2,
                     length = 0.1/1.25,
                     col = adjustcolor(col_sd, alpha.f = 200/255))
)
with(draws_delta,
     VertHist(data = Mod360.180(deg(b_x)), 
              main = 'change in mean angle',
              ylim = c(-90, 90),
              col = adjustcolor(col_sd, alpha.f = 100/255),
              axes = F,
              cex.axis = 0.7))
abline(h = 0,
       col = 'gray',
       lwd = 7)
axis(1)
axis(2, at = -6:6*15)

with(draws_delta, paste0(mean(b_x > 0)*100, '%') ) #nearly all estimates suggest a rightwards turn

with(draws_delta, paste0( round(
                        deg(median.circular(x =
                             circular(b_x,
                                  template = 'none')
                                  )
                            ) ), 
                            '¬∞')
     ) #the size recovered is similar to the simulated turn of 210-180

watson.two.test(cd_control, cd_treatment)#no difference detected


```

Uncertainty in the example data results in a wide range of posterior estimates for the treatment direction.
Nonetheless, $\>95\%$ of estimates for change in ùúá are to the right of 0¬∞, suggesting a change in direction.

## Test the direction change hypothesis

We can investigate this further with model comparison by fitting models with no effects of treatment, and effects on only kappa.
We do this by setting the formula for $\mu$ and $\kappa$ to `~1` (estimate intercept only).

```{r LOO-CV direction change}
#model with effects of treatment on kappa, but not mu
model_kappadelta =  brm(formula = bf(y~1,
                                     kappa~x),
               data = dt_delta, 
               family = unwrap_von_mises,
               prior = prior_delta[c(1,3:4),], # the all kappa & 1st mu prior
               stanvars = stan_unwrap_fun + modulo_circular_fun,
               silent = 2,
               backend = 'cmdstan'
)
#model with no effects of treatment
model_nodelta =  brm(formula = bf(y~1,
                                  kappa~1),
               data = dt_delta, 
               family = unwrap_von_mises,
               prior = prior_delta[c(1,3),], # intercept kappa & mu priors
               stanvars = stan_unwrap_fun + modulo_circular_fun,
               silent = 2,
               backend = 'cmdstan'
)
#all models converge well
print(
  list(`treat. kappa` = 
    summary(model_kappadelta),
    `unwrapped rhat` = 
    UnwrapRhats(model_kappadelta,
                variable = c('Intercept'),
                regex = FALSE
                ),
    `no treat.` = 
    summary(model_nodelta),
    `unwrapped rhat no treat.` = 
    UnwrapRhats(model_nodelta,
                variable = c('Intercept'),
                regex = FALSE
                )
    ),
  digits = 3
)

loo_delta = loo(model_delta)
loo_kappadelta = loo(model_kappadelta)
loo_nodelta = loo(model_nodelta)
print(loo_compare(loo_delta, loo_kappadelta, loo_nodelta))
```

In this case there is uncertainty about the effect of treatment on direction.
Although the model with a change in direction indicates the change to be very consistent (95% CI do not overlap with 0¬∞), these differences could also be explained well by a null model with no change.
Since the median estimate is close to the true value of 30¬∞, the model's estimates appear to be robust, if not conclusive.
Conversely, we can conclude that there was no effect of treatment on concentration, since `model_kappadelta` is a much worse fit than the null model (`model_nodelta`).

# Change in concentration

An experimental treatment may also affect concentration independently of mean direction.
In this example the simulated data the treatment has exactly the same $\mu$ (0¬∞) as the control, but $\kappa$ decreases by $>80\%$ for the treatment.

```{r Simulate a decrease in concentration}
par(pty = 's')
par(mar = c(0,0,0,0))
par(mfrow = c(1,2))

cd_3 = DescriptCplot(m = 0,
                     k = 3,
                     ndata = ndata,
                     mvcol = col_obs,
                     sdcol = NA,
                     denscol = NA,
                     refline = c0,
                     save_sample = TRUE)
cd_0.5 = DescriptCplot(m = 0,
                       k = 0.5,
                       ndata = 20,
                       pcol = col_treat,
                       mvcol = col_treat,
                       sdcol = NA,
                       denscol = NA,
                       refline = c0,
                       save_sample = TRUE)
```

By default, the assumptions for this model would be the same as for the change in angle: we want to be able to account for any potential effects of the treatment on both $\mu$ and $\kappa$, even if we suspect that the treatment only affects one parameter.
We can therefore use the same model as for the change in angle.

```{r Fit treatment concentration model}
dt_conc = data.frame(y = rad( as.numeric( c(cd_3, cd_0.5) ) ), 
                      x = c(rep(0, length(cd_3)), rep(1, length(cd_0.5))) )

#formula for a circular model with predictor x
form_conc = bf(y~x,
                kappa~x,
                family = unwrap_von_mises)

prior_conc = prior('normal(0,3*pi()/2)', class = 'Intercept', dpar = 'mu') + 
                prior('normal(0,pi()/2)', class = 'b', dpar = 'mu') + 
                prior('normal(3,3)', class = 'Intercept', dpar = 'kappa') + 
                prior('normal(0,3)', class = 'b', dpar = 'kappa')

model_conc = brm(formula = form_conc, 
                  data = dt_conc,
                  family = unwrap_von_mises,
                  prior = prior_conc, # the kappa and mu priors 
                  stanvars = stan_unwrap_fun + modulo_circular_fun, 
                  silent = 2, backend = 'cmdstan' ) 
summary(model_conc)
```

The model successfully recovers a large change in $\kappa$ caused by the treatment, alongside only a neglible potential change in $\mu$ (approximately equal posterior density either to the left and right of 0¬∞).
Since the model formula is identical to the change in direction example, we can extract the predictions in the same way.

```{r Inspect predictions for change in kappa}

draws_conc = as_draws_df(model_conc)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(1,3))
PCfun(cd_3,
      col = col_obs,
      sep = 0.05,
      shrink = 1.25,
      plot_rho = FALSE)
Draws2Cont(draws_conc,
           x_string = 'sin(Intercept)*A1(softplus(Intercept_kappa))',
           y_string = 'cos(Intercept)*A1(softplus(Intercept_kappa))',
)
arrows.circular(x = circular(0,
                             units = 'degrees',
                             rotation = 'clock',
                             zero = pi/2),
                y = A1(3),
                col = col_obs,
                lwd = 5,
                length = 0.1/1.25
)
with(draws_conc,
     arrows.circular(x = median.circular(x =
                             circular(Intercept,
                                  rotation = 'clock',
                                  zero = pi/2)
                                  ),
                     y = A1(softplus(x = median(x = Intercept_kappa))),
                     lwd = 2,
                     length = 0.1/1.25,
                     col = adjustcolor(col_sd, alpha.f = 200/255))
)

PCfun(cd_0.5,
      col = col_treat,
      sep = 0.05,
      shrink = 1.25,
      plot_rho = FALSE)
Draws2Cont(draws_conc,
           x_string = 'sin(Intercept+b_x)*A1(softplus(Intercept_kappa+b_kappa_x))',
           y_string = 'cos(Intercept+b_x)*A1(softplus(Intercept_kappa+b_kappa_x))',
)
arrows.circular(x = circular(0,
                             units = 'degrees',
                             rotation = 'clock',
                             zero = pi/2),
                y = A1(0.5),
                col = col_treat,
                lwd = 5,
                length = 0.1/1.25
)
with(draws_conc,
     arrows.circular(x = median.circular(x =
                             circular(Intercept + b_x,
                                  rotation = 'clock',
                                  zero = pi/2)
                                  ),
                     y = A1(softplus(x = median(x = Intercept_kappa +
                                                  b_kappa_x))),
                     lwd = 2,
                     length = 0.1/1.25,
                     col = adjustcolor(col_sd, alpha.f = 200/255))
)
#calculate contrast on true scale by softplus transforming estimates
with(draws_conc,
     VertHist(data = softplus(Intercept_kappa+b_kappa_x) - softplus(Intercept_kappa), 
              main = 'change in kappa',
              ylim = c(-10, 1),
              col = adjustcolor(col_kappa, alpha.f = 100/255),
              cex.axis = 0.7))
abline(h = 0,
       col = 'gray',
       lwd = 7)

with(draws_conc, paste0(mean(b_kappa_x < 0)*100, '%') ) #nearly all estimates suggest a reduction in kappa

watson.two.test(cd_3, cd_0.5)#no difference detected

```

Although there is some uncertainty in the particular size of the change in $\kappa$, $99\%$ of posterior estimates support a treatment effect that decreases $\kappa$.
*N.B.* Since $\kappa$ is estimated on the inverse-softplus scale, the estimates for the control and treatment need to be calculated and then softplus transformed before a difference in $\kappa$ can be calculated on its true scale.

A compare two sets of data that may differ in $\mu$, $\kappa$, or both is to apply the Watson two-sample test for homogeneity.
For this sample size and combination of sample $\kappa$ values, the test fails to detect difference (although the p-value is relatively small).
Given that all parts of this hypothesis can be modelled, we can instead test the hypothesis of a change in $\kappa$ by model comparison, as we did for the change in direction.

## Test the direction change hypothesis

We can investigate this further with model comparison by fitting models with no effects of treatment, and effects on only kappa.
We do this by setting the formula for $\mu$ and $\kappa$ to `~1` (estimate intercept only).

```{r LOO-CV concentration change}
#model with effects of treatment on kappa, but not mu 
model_conc_kappa =  brm(formula = bf(y~1,
                                          kappa~x),                
                             data = dt_conc,                 
                             family = unwrap_von_mises,
                             prior = prior_conc[c(1,3:4),], # the all kappa & 1st mu prior                
                             stanvars = stan_unwrap_fun + modulo_circular_fun,    
                             silent = 2,                
                             backend = 'cmdstan' ) #model with no effects of treatment 
model_conc_nokappa =  brm(formula = bf(y~1,
                                       kappa~1),
                          data = dt_conc,
                          family = unwrap_von_mises,
                          prior = prior_conc[c(1,3),], # intercept kappa & mu priors                
                          stanvars = stan_unwrap_fun + modulo_circular_fun,                
                          silent = 2,                
                          backend = 'cmdstan' ) 
#all models converge well 
print(   list(`treat. kappa` =      summary(model_conc_kappa),     
              `unwrapped rhat` =
                UnwrapRhats(model_conc_kappa,
                            variable = c('Intercept'),
                            regex = FALSE
                                  ),
              `no treat.` =      summary(model_conc_nokappa),
              `unwrapped rhat no treat.` =
                UnwrapRhats(model_conc_nokappa,
                            variable = c('Intercept'),
                            regex = FALSE
                            )     
              ),   digits = 3 )  
loo_conc = loo(model_conc) 
loo_conc_kappa = loo(model_conc_kappa) 
loo_conc_nokappa = loo(model_conc_nokappa) 
print(loo_compare(loo_conc, loo_conc_kappa, loo_conc_nokappa))
```

In this case the hypothesis tests are clear, the effect of change in kappa (present in both our original model and the kappa only model) improves model predictive density.
As we might have also expected, the effect of treatment on $\mu$, present in our original model but not the $\kappa$-only model, does not improve predictive density, so there is little evidence that the treatment affects $\mu$.

# High inter-individual correlation

```{r Simulate high interindividual correlation}
kappa_mu1 = 2.0
kappa_id1 = 5.0

ndata = 10 # moderate sample size
set.seed(0120810506)#ISBN Batschelet, 1981
dt1 = rvonmises(n = 10,
                mu = c0,
                kappa = kappa_mu1)
print(round(dt1))

par(pty = 's')
par(mar = c(0,0,0,0))
par(mfrow = c(3,4))
dt_id1 = mapply(FUN = DescriptCplot,
                m = dt1, 
                seed = 1000*1:length(dt1), #different seed for each
                save_sample = TRUE,
                k = kappa_id1,
                ndata = 20,
                refline = 0,
                sdcol = NA,
                denscol = NA,
                SIMPLIFY = FALSE
                )
#Add the population of biases
DescriptCplot(k = kappa_mu1,
              ndata = 10,
              refline = 0,
              sdcol = NA,
              denscol = NA,
              pcol = NA,
              cicol = col_sd,
              mvcol = col_sd
)
points.circular(dt1,
                bins = 360/5-1,
                stack = TRUE,
                sep = 0.05,
                shrink = 1.25,
                col = col_rho
)

dt_comb1 = do.call(what = c,
                   args = dt_id1)
PCfun(angles = dt_comb1,
      col = 'gray25',
      shrink = 3.0)
mle_comb1 = mle.vonmises(x = dt_comb1,bias = TRUE)
ci_comb1 = with(mle_comb1,
                CI_vM(angles = dt_comb1,
                      m1 = mu,
                      k1 = kappa,
                      alternative = 'two.sided')
)
with(mle_comb1,
     {
       arrows.circular(x = circular(mu,
                                    units = 'degrees',
                                    rotation = 'clock',
                                    zero = pi/2),
                       y = A1(kappa),
                       lwd = 3,
                       col = col_pdf,
                       length = 0.1
       )
     }
)
```

```{r Rayleigh tests on combined data and 1st trials}
rayleigh.test(dt_comb1)
rayleigh.test(dt_comb1[1+0:9 * 20])

```

```{r Model individuals (high correlation)}
#fit a mixed effects unwrap model
#can normal random effects sufficiently capture that structure?
form_highcorr = bf(y ~ fmu + zmu,
                  fmu ~ 1,
                  zmu ~ 0 + ID,
                  kappa ~ 1 + (1|ID),
                  nl = TRUE)

prior_highcorr =  prior('normal(0,pi()/2)', class = 'b', nlpar = 'fmu') +
                  prior('unwrap_von_mises_vect(0, log1p_exp(kappamu))',
                        nlpar  = 'zmu',  class = 'b') +
                  set_prior("target += normal_lpdf(kappamu | 3, 3)", #expect high concentration (low variation) 
                            check = FALSE) +
                  prior('normal(3,2)', class = 'Intercept', dpar = 'kappa') +
                  prior('student_t(3, 0, 0.5)', class = 'sd', dpar = 'kappa')

#set up required Stan functions
mod_circular_fun = stanvar(scode = "
    real mod_circular(real y) {
      return fmod(y + pi(), 2*pi()) - pi();
    }
  ",
                           block = 'functions')
unwrap_von_mises = custom_family(
  "unwrap_von_mises", dpars = c("mu", "kappa"),
  links = c('identity',#brms cannot accept custom link functions, do via nl instead
            "softplus"), 
  lb = c(-pi, 0), ub = c(pi, NA),
  type = "real",
)

stan_unwrap_fun = stanvar(scode = "
    real unwrap_von_mises_lpdf(real y, real mu, real kappa) {
      return von_mises_lpdf(y | mod_circular(mu), kappa);
    }
    real unwrap_von_mises_rng(real mu, real kappa) {
      return von_mises_rng( mod_circular(mu) , kappa);
    }
    real unwrap_von_mises_vect_lpdf(vector y, real mu, real kappa) {
    real tmp = 0;
    for(i in 1:size(y))
    {
    tmp = tmp + unwrap_von_mises_lpdf(y[i] | mu, kappa);
    }
      return tmp;
    }
  ",
                          block = 'functions') 

stan_kappamu = stanvar(scode = "
real kappamu;
                           ",
                           block = "parameters") + 
  stanvar(scode = "
real kappa_mu = log1p_exp(kappamu);
          ", 
          block = 'genquant')

stan_modmu =   stanvar(scode = "
  vector [K_fmu] mod_mu;
  for(i in 1:size(mod_mu))
  {
    mod_mu[i] = mod_circular(b_fmu[i]);
  }
  vector [K_zmu] mod_zmu;
  for(i in 1:size(mod_zmu))
  {
    mod_zmu[i] = mod_circular(b_zmu[i]);
  }
          ", 
                       block = 'genquant')

dt_highcorr = data.frame(y = rad(unlist(dt_id1)),
                             ID = factor(x = sort(rep(1:length(dt_id1),
                                                      times = length(dt_id1[[1]]))),
                                         ordered = FALSE)
                             )

bmod_highcorr = brm(
          formula = form_highcorr,
           data = dt_highcorr,
           family = unwrap_von_mises,
           stanvars = stan_unwrap_fun + mod_circular_fun + stan_kappamu + stan_modmu,
           prior = prior_highcorr,
           cores = 4,
           backend = 'cmdstan'
          )

```

```{r Inspect the high correlation individuals model}

sm_highcorr = summary(bmod_highcorr)
print(sm_highcorr, digits = 2)
#random effects zmu looks bad, but good after unwrapping
UnwrapRhats(bmod_highcorr,
            variable = '^b_zmu')
```

```{r Plot the high correlation individuals model}

draws_highcorr = as_draws_df(bmod_highcorr)

par(pty = 's')
par(mar = c(0,0,0,0),
    mfrow = c(3,4))
for(i in 1:length(dt_id1) )
{
  mu_name = paste0('b_zmu_ID',i)
  kappa_name = paste0('r_ID__kappa[',i,',Intercept]')
  PCfun(dt_id1[[i]],
        col = col_obs,
        sep = 0.05,
        shrink = 1.25,
        plot_rho = FALSE)
  arrows.circular(x = dt1[i],
                  y = A1(kappa_id1),
                  col = col_rho,
                  lwd = 5,
                  length = 0.1/1.25
  )
  Draws2Cont(draws_highcorr,
             x_string = 'sin(b_fmu_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)))',
             y_string = 'cos(b_fmu_Intercept + get(mu_name))*
                         A1(softplus(Intercept_kappa+get(kappa_name)))'
             )
  # with(draws_highcorr,
  #      points(x = sin(b_fmu_Intercept + get(mu_name))*
  #                   A1(softplus(Intercept_kappa+get(kappa_name))),
  #             y = cos(b_fmu_Intercept + get(mu_name))*
  #                   A1(softplus(Intercept_kappa+get(kappa_name))),
  #             col = adjustcolor(col = col_sd,
  #                               alpha.f = 1/255),
  #             pch = 19)
  # )
  with(draws_highcorr,
       arrows.circular(x = median.circular(
                             circular(x = 
                             mod_circular(b_fmu_Intercept + get(mu_name)),
                                                    units = 'radians',
                                                    rotation = 'clock',
                                                    zero = pi/2)
                                           )[1],
                       y = A1(softplus(median(Intercept_kappa+get(kappa_name)))),
                       lwd = 2,
                       length = 0.1/1.25,
                       col = adjustcolor(col_sd, alpha.f = 200/255))
  )
}

#Add the population of biases
DescriptCplot(k = kappa_mu1,
              ndata = 10,
              refline = 0,
              sdcol = NA,
              denscol = NA,
              pcol = NA,
              cicol = NA,
              mvcol = col_rho
)
points.circular(dt1,
                bins = 360/5-1,
                stack = TRUE,
                sep = 0.05,
                shrink = 1.25,
                col = col_rho
)
Draws2Cont(draws = draws_highcorr,
           x_string = 'sin(b_fmu_Intercept)*
             A1(softplus(kappa_mu))',
           y_string = 'cos(b_fmu_Intercept)*
             A1(softplus(kappa_mu))'
           )
# with(draws_highcorr,
#      points(x = sin(b_fmu_Intercept)*
#               A1(softplus(kappa_mu)),
#             y = cos(b_fmu_Intercept)*
#               A1(softplus(kappa_mu)),
#             col = adjustcolor(col = col_sd,
#                               alpha.f = 1/255),
#             pch = 19)
#      )

with(draws_highcorr,
     arrows.circular(x = mean.circular(circular(b_fmu_Intercept,
                                                  units = 'radians',
                                                  rotation = 'clock',
                                                  zero = pi/2)
     )[1],
     y = A1(softplus(median(kappa_mu))),
     lwd = 2,
     length = 0.1/1.25,
     col = adjustcolor(col_sd, alpha.f = 200/255))
)


with(draws_highcorr,
     VertHist(data = softplus(kappa_mu), 
              main = 'kappa_mu',
              ylim = c(0, 5),
              col = adjustcolor(col_kappa, alpha.f = 100/255),
              cex.axis = 0.7))
abline(h = kappa_mu1,
       col = col_rho,
       lwd = 7)
with(draws_highcorr, paste0(mean(softplus(kappa_mu) < kappa_mu1)*100, '%') ) #most estimates are close to correct
```
